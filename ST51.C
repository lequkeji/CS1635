/**********************
 * 文 件 名  ： CS1635.C
 * 作    者  ： Zhaoxun
 * 创作时间  ： 2021.08.26
 * 功能描述  ： AT1635
 * 说    明  ： 驱动户户通数码管
 * 所用变量  ： number[],Byte,p ,add,value,K
 * 用于学习，禁止商用。
**********************/
#include <REGX52.H>
#include <intrins.h>
#include "CS1635.H"

/*****************************************************************
函 数 : surface[]
功 能 : 数码管显示数字
说 明 : 0~17

*****************************************************************/
unsigned char code number[] = 
{// 0    1    2    3    4    5    6    7    8    9    10/A 11/b 12/C 13/d 14/E 15/F 16/- 17/.
	0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,0x40,0x00};

/*****************************************************************
函 数 : Start();
功 能 : 开始
说 明 : 开始条件

*****************************************************************/
void Start(void)
{
    DIO = 1;//发送起始条件的数据信号
    CLK = 1;
    _nop_();//起始条件建立时间大于4.7us,延时
    _nop_();
    DIO = 0;//发送起始信号
    _nop_();
    CLK = 0;//准备发送或接收数据
}

/*****************************************************************
函 数 : Stop():
功 能 : Stop函数
说 明 : 结束

*****************************************************************/
void Stop(void)
{
    CLK = 0;
    _nop_();
    _nop_();
    DIO = 0;
    _nop_();
    _nop_();
    CLK = 1;
    _nop_();
    _nop_();
    _nop_();
    DIO = 1;
    _nop_();
    CLK = 0;
    DIO = 0;
}

/*****************************************************************
函 数 : Writebyte();
功 能 : 发送8bit数据，从低位开始
说 明 : Byte:发送的数据

*****************************************************************/
void Writebyte(unsigned char Byte)
{
    unsigned char i;
    for(i=0;i<8;i++)
    {
        CLK=0;
        if(Byte&0x01)DIO=1;
        else DIO=0;
        Byte=Byte>>1;
        _nop_();
        CLK=1;
  }
    //8位数据传送完
    CLK = 0;//判断芯片发过来的ACK应答信号
    _nop_();
    while(DIO==1);
    _nop_();
    CLK = 1;
    _nop_();
}

/*****************************************************************
函 数 : disp0();
功 能 : 显示函数，地址自加
说 明 : 地址自动加1，写数据到显示寄存器
        p：开始显示的数字 ，后移一位自动加一
*****************************************************************/
void disp0(unsigned char p)
{
     unsigned char i;
     Start();
     Writebyte(0x40);           //数据命令设置：地址自动加1，写数据到显示寄存器
     Stop();
     Start();
     Writebyte(0xC0);           //地址命令设置：初始地址为00H
     for(i=0;i<4;i++)           //发送4字节数据到显存
     {
         Writebyte(number[p]);
         p++;
     }
     Stop();
     Start();
     Writebyte(0x8F);           //显示控制命令：开显示，脉冲宽度为11/16.
     Stop();
}

/*****************************************************************
函 数 : disp();
功 能 : 显示函数，固定地址写数据
说 明 : addr:1~4,value:1~17,K:0~8
关显示：0x80~70x88,亮 度 ：0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F
*****************************************************************/
void disp(unsigned char add,value,K)
{
    Start();
    Writebyte(0x44);        //数据命令设置：固定地址，写数据到显示寄存器
    Stop();
    Start();
    Writebyte(0xC0|add-1);  //地址命令设置：写入add对应地址
    Writebyte(number[value]);//给add地址写数据
    Stop();
    Start();
    Writebyte(0x80|K+7);     //显示控制命令：开显示，脉冲宽度为11/16.
    Stop();
}

/*****************************************************************
函 数 : read_key()；
功 能 : 读按键程序
说 明 : K1   K4   K3   K5   K6   K2
        0xK6 0xK5 0xK4 0xK2 0xK7 0xK3
        6    5    4    2    7    3
*****************************************************************/
unsigned char read_key()
{
    unsigned char key,i,rekey;
    Start();
    Writebyte(0x42);    //写读键指令0x42
    DIO = 1;
    for(i=0;i<8;i++)
    {
        CLK = 0;
        _nop_();
        rekey=rekey>>1; //先读低位
        _nop_();
        CLK = 1;
        if(DIO) rekey=rekey|0x80;
        else    rekey=rekey|0x00;
       _nop_();
    }
    CLK = 0;            //判断芯片发过来的ACK应答信号
    _nop_();
    while(DIO==1);
    _nop_();
    CLK = 1;
    _nop_();
    Stop();
    key=rekey&0X0F;     //读取后四位值
    return key;
}
